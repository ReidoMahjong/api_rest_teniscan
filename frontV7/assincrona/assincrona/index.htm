<!doctype html>
<html lang="pt-br">
  <head>
    <title>Programação Assíncrona</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="style.css">
    <script>
      document.addEventListener('keydown', function(e) {
	  switch(e.code) {
	  case 'PageDown':
	      e.preventDefault(); // Prevent default browser action
	      window.scrollBy(0, window.innerHeight);
	      break;
	  case 'PageUp':
	      e.preventDefault(); // Prevent default browser action
	      window.scrollBy(0, -(window.innerHeight));
	      break;
	  }
      });  
    </script>
  </head>
  <body>
    <section class="capa">
      <h2>Programação Assíncrona com Javascript</h2>
      <address rel="author">Thiago Leucz Astrizi <br> Faculdade Municipal de Palhoça</address>
      <time datetime="2025-10-28">28 de outubro de 2025</time>
    </section>
    <section class="duas-colunas">
      <h2>Executando Código Síncrono</h2>
      <div>
	<img src="cpu.gif" alt="Imagem de uma CPU"
	     title="Fonte: https://giphy.com/gifs/citilinkofficial-pc-cooler-cpu-qgXLhRA7eddinjVPP9">
      </div>
      <div>
<pre><span class="keyword">function</span> fatorial(n){
  <span class="keyword">if</span>(n === 0 || n === 1){
    <span class="keyword">return</span> 1;
  }
  <span class="keyword">let</span> resultado = 1;
  <span class="keyword">for</span>(<span class="keyword">let</span> i = 2; i &lt;= n; i ++){
    resultado *= i;
  }
  <span class="keyword">return</span> resultado;
}

<span class="keyword">const</span> fatorialGrande = fatorial(1000000);
</pre>
	<ul>
	  <li>Processador fica ocupado até terminar de executar o código.</li>
	  <li>A velocidade da execução depende da velocidade do processador.</li>
	</ul>
      </div>
    </section>
    <section class="duas-colunas">
      <h2>Executando Código Assíncrono</h2>
    <div>
      <img src="cpu2.png" alt="Imagem de CPU dormindo" title="Fonte: ChatGPT.">
    </div>
    <div>
      <ul>
	<li>E se pedirmos para nosso código se comunicar pela rede?</li>
	<li>Ou lermos dados que estão no disco?</li>
	<li>O que o processador faz após o pedido ter sido feito,
	enquanto o resultado não chega?</li>
      </ul>
    </div>
    </section>
    <section>
      <h2>Modelo Síncrono x Modelo Assíncrono</h2>
      <ul>
	<li>Um programa quer ler duas informações da rede e combinar os resultados.</li>
	<li>Modelo síncrono, uma só thread:</li>
      </ul>
	<span class="ocupado" style="width: 10vw"></span><span class="parado" style="width: 30vw"></span><span class="ocupado" style="width: 10vw"></span><span class="parado" style="width: 30vw"></span><span class="ocupado" style="width: 10vw"></span>
    </section>
    <section>
      <h2>Modelo Síncrono x Modelo Assíncrono</h2>
      <ul>
	<li>Um programa quer ler duas informações da rede e combinar os resultados.</li>
	<li>Modelo síncrono, uma só thread:</li>
      </ul>
	<span class="ocupado" style="width: 10vw"></span><span class="parado" style="width: 30vw"></span><span class="ocupado" style="width: 10vw"></span><span class="parado" style="width: 30vw"></span><span class="ocupado" style="width: 10vw"></span>
	<ul>
	<li>Modelo síncrono, duas threads</li>
	</ul>
	<span class="ocupado" style="width: 10vw"></span><span class="parado" style="width: 30vw"></span><span class="ocupado" style="width: 10vw"></span><span class="ocupado" style="width: 10vw"></span>
	<br>
	<span class="ocupado" style="width: 10vw"></span><span class="parado" style="width: 30vw"></span><span class="ocupado" style="width: 10vw"></span>
    </section>
    <section>
      <h2>Modelo Síncrono x Modelo Assíncrono</h2>
      <ul>
	<li>Um programa quer ler duas informações da rede e combinar os resultados.</li>
	<li>Modelo síncrono, uma só thread:</li>
      </ul>
      <span class="ocupado" style="width: 10vw"></span><span class="parado" style="width: 30vw"></span><span class="ocupado" style="width: 10vw"></span><span class="parado" style="width: 30vw"></span><span class="ocupado" style="width: 10vw"></span>
      <ul>
	<li>Modelo síncrono, duas threads</li>
      </ul>
      <span class="ocupado" style="width: 10vw"></span><span class="parado" style="width: 30vw"></span><span class="ocupado" style="width: 10vw"></span><span class="ocupado" style="width: 10vw"></span>
	<br>
	<span class="ocupado" style="width: 10vw"></span><span class="parado" style="width: 30vw"></span><span class="ocupado" style="width: 10vw"></span>
	<ul>
	  <li>Modelo assíncrono</li>
	</ul>
	<span class="ocupado" style="width: 20vw"></span><span class="vazio" style="width: 30vw"></span><span class="ocupado" style="width: 10vw"></span><span class="vazio" style="width: 2vw"></span><span class="ocupado" style="width: 10vw"></span>
	<ul>
	  <li>O processador pede para ser avisado quando a tarefa termina.</li>
      </ul>
    </section>
        <section>
      <h2>Modelo Síncrono x Modelo Assíncrono</h2>
      <ul>
	<li>Um programa quer ler duas informações da rede e combinar os resultados.</li>
	<li>Modelo síncrono, uma só thread:</li>
      </ul>
      <span class="ocupado" style="width: 10vw"></span><span class="parado" style="width: 30vw"></span><span class="ocupado" style="width: 10vw"></span><span class="parado" style="width: 30vw"></span><span class="ocupado" style="width: 10vw"></span>
      <ul>
	<li>Modelo síncrono, duas threads</li>
      </ul>
	<span class="ocupado" style="width: 10vw"></span><span class="parado" style="width: 30vw"></span><span class="ocupado" style="width: 10vw"></span><span class="ocupado" style="width: 10vw"></span>
	<br>
	<span class="ocupado" style="width: 10vw"></span><span class="parado" style="width: 30vw"></span><span class="ocupado" style="width: 10vw"></span>
	<ul>
	  <li>Modelo assíncrono</li>
	</ul>
	<span class="ocupado" style="width: 20vw"></span><span class="vazio2" style="width: 30vw"></span><span class="ocupado" style="width: 10vw"></span><span class="vazio" style="width: 2vw"></span><span class="ocupado" style="width: 10vw"></span>
	<ul>
	<li>Enquanto isso ele pode fazer outras tarefas.</li>
      </ul>
	</section>
	<section>
	  <h2>Funções de Retorno de Chamada (<i>callbacks</i>)</h2>
	  <ul>
	    <li>Uma abordagem para funções assíncronas:
	    usar <i>callbacks</i> (funções de retorno de
	    chamadas).</li>
	</ul>
	<pre>setTimeout(() => console.log(<span class="string">"Tique"</span>), 1000);</pre>
        <ul>
	  <li>A função <code>setTimeout</code> recebe como argumento:</li>
	  <li>
	  <ol>
	    <li>Uma função a ser executada no futuro.</li>
	    <li>O tempo em milissegundos para esperar até executar a função.</li>
	  </ol>
	  </li>
        </ul>
	<pre>setInterval(() => console.log(<span class="string">"Taque"</span>), 2000);</pre>
	<ul>
	  <li>A função <code>setInterval</code> recebe como argumento:</li>
	  <li><ol>
	    <li>Uma função a ser executada periodicamente.</li>
	    <li>O ciclo em milissegundos que separa cada execução da função.</li>
	  </ol></li>
	  <li>Ambas as funções retornam um número que identifica o evento temporizado.</li>
	  <li>Para cancelar a execução futura do evento, dado seu número, use:</li>
        </ul>
	<pre>clearTimeout(eventoID);</pre>
    </section>
    <section>
      <h2>Promessas</h2>
      <div>
      <ul>
	<li>Uma promessa é um recibo representando um valor que pode
	  ainda não estar disponível.</li>
	<li>Toda promessa possui um método <code>then</code> que
	permite que você passe uma função que deve ser executada
	  quando a promessa se resolver.</li>
	<li>Se a promessa já foi resolvida, a função é chamada
	  imediatamente.</li>
	<li>Você pode criar uma promessa
	usando <code>Promise.resolve</code>. Esta função garante que o
	objeto passado deve estar dentro de uma promessa, caso ele
	ainda não esteja em uma.</li>
      </ul>
      </div>
      <div>
	<pre><span class="keyword">let</span> quinze = Promise.resolve(15);
quinze.then(valor => console.log(<span class="string">`Recebi um ${valor}.`</span>));
<span class="comentario">// Imprime imediatamente: 'Recebi um 15.'</span></pre>
      </div>
    </section>
    <section>
      <h2>fetch</h2>
      <div>
	<ul>
	  <li>É possível fazer requisições HTTP usando Javascript.</li>
	  <li>Para isso usamos a função <code>fetch</code>.</li>
	  <li>Ela recebe um endereço e retorna uma promessa com a
	    resposta da requisição HTTP.</li>
	  <li>Pode-se ler os cabeçalhos da resposta HTTP usando o
	  método <code>get</code> que aceita o nome de uma parte do
	  cabeçalho.</li>
	</ul>
      </div>
      <div>
<pre>fetch(<span class="string">"exemplo.htm"</span>).then(resposta => {
  console.log(resposta.status);
  <span class="comentario">// → 200</span>
  console.log(resposta.headers.get(<span class="string">"Content-Type"</span>));
  <span class="comentario">// → text/html</span>
});
</pre>
<ul>

</ul>
      </div>
    </section>
    <section>
      <h2>fetch</h2>
      <div>
	<ul>
	  <li>Para ler o verdadeiro conteúdo de uma resposta HTTP,
	    precisamos usar o seu método <code>text()</code>.
	  <li>
	    Mas este método não retorna o conteúdo. Mas sim uma
	    promessa com o conteúdo.
	  </li>
	  <li>
	    O método <code>then()</code> tem como valor de retorno uma
	    promessa com o retorno da função <i>callback</i> passada
	    para ele.
	  </li>
	  <li>
	    Sendo assim, podemos encadear a chamada dos
	    métodos <code>then()</code> para serem executados à medida
	    que cada promessa encadeada é cumprida.
	  </li>
	  <li>Além do <code>text()</code>, você pode usar o
	  método <code>json()</code> para obter uma promessa para o
	  conteúdo da página em formato JSON, e rejeitar se o
	  conteúdonão estiver neste formato.</li>
	</ul>
      </div>
      <div>
<pre>fetch(<span class="string">"exemplo.htm"</span>)
    .then(resposta => {resposta.text()})
    .then(texto => console.log(texto));
</pre>
      </div>
    </section>
    <section>
      <h2>fetch</h2>
      <ul>
	<li>Por padrão a função <code>fetch</code> usa uma requisição
	  GET.</li>
	<li>É possível modificar isso. Abaixo enviamos requisição
	DELETE:</li>
      </ul>
      <pre>fetch(<span class="string">"example/data.txt"</span>, {method: <span class="string">"DELETE"</span>}).then(resp => {
  console.log(resp.status);
  <span class="comentario">// → 405 (Não permitido)</span>
});</pre>
      <ul>
	<li>Para enviar um corpo para sua requisição PUT ou POST, pode-se adicionar um corpo na requisição.</li>
	<li>É possível também adicionar cabeçalhos na requisição.</li>
      </ul>
<pre>
let dadosJSON = {<span class="string">"nome"</span>: <span class="string">"João"</span>, <span class="string">"idade"</span>: 30, 
                 <span class="string">"matriculado"</span>: false };
fetch(<span class="string">"exemplo.htm"</span>, {
  method: <span class="string">"POST"</span>,
  headers: { <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,},
  body: JSON.stringify(dadosJSON),
})
</pre>
    </section>
    <section>
      <h2>Segurança</h2>
      <p>
	Imagine o seguinte cenário:
      </p>
      <ol>
	<li>Você visita <a href="#">http://www.mafia.org</a></li>
      </ol>
    </section>
    <section>
      <h2>Segurança</h2>
      <ol>
	<li>Você visita <a href="#">http://www.mafia.org</a></li>
	<li>A página tem um script que faz uma requisição <code>fetch</code> para <a href="#">http://www.seubanco.com.br</a>.</li>
      </ol>
      <img src="mafia.png" alt="Imagem ilustrativa">
    </section>
    <section>
      <h2>Segurança</h2>
      <ol>
	<li>Você visita <a href="#">http://www.mafia.org</a></li>
	<li>A página tem um script que faz uma requisição <code>fetch</code> para <a href="#">http://www.seubanco.com.br</a>.</li>
      </ol>
      <img src="mafia.png" alt="Imagem ilustrativa">
      <ol start="3">
	<li>O navegador envia o pedido e obtém a resposta.</li>
      </ol>
    </section>
    <section>
      <h2>Segurança</h2>
      <ol>
	<li>Você visita <a href="#">http://www.mafia.org</a></li>
	<li>A página tem um script que faz uma requisição <code>fetch</code> para <a href="#">http://www.seubanco.com.br</a>.</li>
      </ol>
      <img src="mafia.png" alt="Imagem ilustrativa" style="max-height: 50%">
      <ol start="3">
	<li>O navegador envia o pedido e obtém a resposta.</li>
	<li>Lendo a resposta, o servidor descobre que o banco não permite que <a href="#">http://www.mafia.org</a> faça requisições.</li>
      </ol>
    </section>
    <section>
      <h2>Segurança</h2>
      <ol>
	<li>Você visita <a href="#">http://www.mafia.org</a></li>
	<li>A página tem um script que faz uma requisição <code>fetch</code> para <a href="#">http://www.seubanco.com.br</a>.</li>
      </ol>
      <img src="mafia.png" alt="Imagem ilustrativa"  style="max-height: 40%">
      <ol start="3">
	<li>O navegador envia o pedido e obtém a resposta.</li>
	<li>Lendo a resposta, o servidor descobre que o banco não permite que <a href="#">http://www.mafia.org</a> faça requisições. Afinal, ele não encontra no cabeçalho da resposta:</li>
      </ol>
      <pre>Access-Control-Allow-Origin: *</pre>
    </section>
        <section>
      <h2>Segurança</h2>
      <ol>
	<li>Você visita <a href="#">http://www.mafia.org</a></li>
	<li>A página tem um script que faz uma requisição <code>fetch</code> para <a href="#">http://www.seubanco.com.br</a>.</li>
      </ol>
      <img src="mafia.png" alt="Imagem ilustrativa"  style="max-height: 40%">
      <ol start="3">
	<li>O navegador envia o pedido e obtém a resposta.</li>
	<li>Lendo a resposta, o servidor descobre que o banco não permite que <a href="#">http://www.mafia.org</a> faça requisições.
	</li>
	<li>O navegador gera um erro. E não mostra a resposta da
	  requisição. O dia é salvo mais uma vez.</li>
      </ol>
	</section>
	<section class="duas-colunas">
	  <h2>Erros em Funções Assíncronas</h2>
	  <div>
	  <p>Para lidar com erros quando você
	    usa <code>setTimeout</code> ou <code>setInterval</code>,
	    você pode usar blocos <code>try...catch</code>.
	  </p>
	  <p>
	    Os blocos precisam estar dentro da função de <i>callback</i>.
	  </p>
	  </div>
	  <div>
<pre>
setTimeout(<span class="keyword">function</span> () {
  <span class="keyword">try</span> {
    funcaoQuePodeFalhar();
  } <span class="keyword">catch</span> (e) {
    console.error(e);<span class="comentario"> // Trata erro</span> 
  }
}, 300)</pre>
	  </div>
	</section>
	<section>
	  <h2>Erros em Funções Assíncronas</h2>
	  <div>
	    <ul>
	      <li>Promessas podem ser cumpridas (sucesso) ou ser
		rejeitadas (falha).</li>
	      <li>A função passada para o <code>then()</code> só
	      executa quando a promessa é cumprida. Não quando é
		rejeitada.</li>
	      <li>Um erro que ocorre em uma função de <i>callback</i>
		executada por um <code>then()</code> faz com que a
		promessa retornada pelo <code>then()</code> seja
		rejeitada.</li>
	      <li>Promessas possuem um método <code>catch()</code>
		semelhante ao <code>then()</code>.</li>
	      <li>Um <code>catch()</code> executa a função
	      de <i>callback</i> somente se a promessa foi
	      rejeitada. Caso contrário, ele apenas retorna a própria
	      promessa.</li>
	    </ul>
	  </div>
	  <div>
<pre>fetch(<span class="string">'https://api.example.com/data'</span>)
  .then(response => {
    <span class="comentario">// Processe a resposta bem-sucedida</span>
  })
  .catch(error => {
    console.error(<span class="string">'Erro na requisição:'</span>, error);
  });</pre>
	  </div>
	</section>
	<section>
	  <h2>Erros em Funções Assíncronas</h2>
	  <div>
	    <ul>
	      <li>O <code>fetch</code> não rejeita sua promessa caso o
	      HTTP gere códigos de retorno 404 (não encontrado) ou 500
		(erro interno de servidor).</li>
	      <li>Para lidar com isso, podemos gerar explicitamente
	      erros quando a requisição não gerou uma resposta
		bem-sucedida.</li>
	      <li>
		Para isso podemos checar o atributo <code>ok</code> da resposta.
	      </li>
	    </ul>
	  </div>
	  <div>
<pre>fetch(<span class="string">'https://api.example.com/eu-nao-existo'</span>)
  .then(resposta => {
    <span class="keyword">if</span>(!resposta.ok) {
      <span class="keyword">throw new</span> Error(<span class="string">`Erro HTTP! Status: ${resposta.status}`</span>);
    }
    <span class="keyword">return</span> resposta.json(); <span class="comentario">// Obtém JSON</span>
  })
  .then(data => {
    console.log(<span class="string">'Dados:'</span>, data);
  })
  .catch(error => {
    console.error(<span class="string">'Erro no fetch:'</span>, error);
  });</pre>
	  </div>
	</section>
	<section>
	  <h2>Criando Funções Assíncronas</h2>
	  <div>
	    <ul>
	      <li>Funções definidas com a
		palavra-chave <code>async</code> se tornam assíncronas.</li>
	      <li>
		Ao serem invocadas, elas retornam uma promessa.
	      </li>
	      <li>Quando seu código retorna, a promessa é cumprida.</li>
	      <li>Se um erro ocorrer no meio delas, a promessa é rejeitada.</li>
	    </ul>
	  </div>
	  <div>
<pre><span class="keyword">async function</span> fatorial(n){
  <span class="keyword">if</span>(n === 0 || n === 1){
    <span class="keyword">return</span> 1;
  }
  <span class="keyword">let</span> resultado = 1;
  <span class="keyword">for</span>(<span class="keyword">let</span> i = 2; i &lt;= n; i ++){
    resultado *= i;
  }
  <span class="keyword">return</span> resultado;
}

fatorial(100).then(valor => console.log(valor));</pre>
	  </div>
	</section>
	<section>
	  <h2>Criando Funções Assíncronas</h2>
	  <div>
	    <ul><li>Uma função assíncrona pode esperar outra função
		assíncrona terminar usando <code>await</code>.</li>
	      <li>Um <code>await</code> interrompe a execução da
	      função assíncrona até que outra função assíncrona execute. O
		valor de sua promessa é então extraído.</li>
	      <li>
		Com isso pode-se escrever código assíncrono de maneira
		semelhante a código síncrono.
	      </li>
	    </ul>
	  </div>
	  <div>
<pre>
<span class="keyword">const</span> fetchData = <span class="keyword">async function</span> (){
  <span class="keyword">let</span> resposta = <span class="keyword">await</span> fetch(<span class="string">'https://pokeapi.co/api/v2/pokemon/ditto'</span>);
  <span class="keyword">if</span>(!resposta.ok){
    <span class="keyword">throw new</span> Error(<span class="string">`Erro HTTP! Status: ${resposta.status}`</span>);
  }
  <span class="keyword">let</span> dados = <span class="keyword">await</span> resposta.json();
  <span class="keyword">return</span> dados;
};

fetchData().then(dados => console.log(dados));
</pre>
	  </div>
	</section>
  </body>
</html>
